# Pseudocode for `solve_ecb_basic`
```
suffix = b''
prev = b'a'*16
for each unknown block at i (starting at 1 cuz 0 is input):
    set prev = previous full block (to preserve same condition)
    set known = b''
    for j in 16
        set fill_size = bs-len(known)-1
        set input_block = prev[:fill_size]
        # record the leak coming from next block
        set c_leak = oracle(input_block)[i - 1][-1]
        set guesses = {}  # in format (c_guess: b)
        for b in 128:
            # 0 because we control only the input
            guesses[oracle(input_block + known + bytes([b]))[0][-1]] = b
        known += bytes([guesses[c_leak]])

    assert len(known) == 16
    suffix += known
    prev = known

    0                1                2                3
src aaaabbbbccccdddd XXXXXXXXXXXXXXXX YYYYYYYYYYYYYYYY ZZZZZZZZZZZZZZZZ
    aaaabbbbccccdddX XXXXXXXXXXXXXXXY YYYYYYYYYYYYYYYZ ZZZZZZZZZZZZZZZ.
    aaaabbbbccccddXX XXXXXXXXXXXXXXYY YYYYYYYYYYYYYYZZ ZZZZZZZZZZZZZZ..
    already have c_leak = block[i-1][-1]
    PPPPPPPPPPPPPPPb
    PPPPPPPPPPPPPPbb
    test all b at input block
    the one that matches with c_leak is the right guess
```
